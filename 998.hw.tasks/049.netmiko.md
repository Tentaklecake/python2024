# Netmiko

## Task1. Базовый сбор команд

Написать функцию с сигнатурой `get_output(device: dict[str, str], command: str) -> str`, аргументами которой являются словарь с параметрами для подключения и команда, которую необходимо выполнить на устройстве.

Допущения:

- для подключения используется библиотека `netmiko`
- платформа - любая доступная
- команда - произвольная, существующая на оборудовании

Пример:

```python
from netmiko import ConnectHandler

device = {
    "device_type": "cisco_xe",
    "host": "192.168.122.101",
    "username": "admin",
    "password": "P@ssw0rd",
}

def get_output(device: dict[str, str], command: str) -> str:
    # <ваша реализация>

if __name__ == "__main__":
    print(get_output(device, "show clock"))
```

## Task2. Исключения

Модифицировать функцию `get_output(device: dict[str, str], command: str) -> str` из [Task1](#task1-базовый-сбор-команд), добавив в нее обработку следующих исключений:

- некорректная пара логин/пароль -> печатаем в stdout "Неправильные логин/пароль для устройства <fqdn/ip устройства>" и возвращаем из функции пустую строку
- таймаут подключения к устройству -> печатаем в stdout "Таймаут подключения к устройству <fqdn/ip устройства>" и возвращаем из функции пустую строку
- все неизвестные исключения -> печатаем в stdout "Неизвестное исключение при работе с устройством <fqdn/ip устройства><класс исключения>:<текст исключения>" и возвращаем из функции пустую строку

Пример:

```python
from netmiko import ConnectHandler
from netmiko.exceptions import # <ваша реализация>

device = {
    "device_type": "cisco_xe",
    "host": "192.168.122.101",
    "username": "admin",
    "password": "P@ssw0rd",
}

def get_output(device: dict[str, str], command: str) -> str:
    # <ваша реализация>

if __name__ == "__main__":
    print(get_output(device, "show clock"))
```

Результат:

```python
# при недоступности устройства:
Таймаут подключения к устройству 192.168.122.102

# при неправильных параметрах доступа
Неправильные логин/пароль для устройства 192.168.122.101

# остальные ошибки
Неизвестная ошибка при работе с устройством 192.168.122.101: ValueError: Unsupported 'device_type' currently supported platforms are: 
```

## Task3. Интерактивный режим

Написать функцию c сигнатурой `clear_logging(device: dict[str, str]) -> bool`, которая очищает буфер syslog-сообщений на cisco оборудовании командой `clear logging`. В качестве аргумента функция принимает словарь с параметрами оборудования для подключения.

Ключевые особенности, которым должна соответствовать функция:

- выполнение команды на оборудовании требует подтверждения операции:
  
  ```text
  router#clear logging
  Clear logging buffer [confirm]
  router#
  ```

  функция должна обеспечить обработку интерактивного события (способ остается за разработчиком)
- должны обрабатываться исключения из задания 2:
  - не подходят логин/пароль -> пишем в stdout "Неправильные логин/пароль для устройства" и возвращаем False из функции
  - таймаут подключения к устройству -> пишем в stdout "Таймаут подключения к устройству" и возвращаем False из функции
  - все неизвестные исключения -> пишем в stdout "Неизвестная ошибка при работе с устройством" и возвращаем False из функции
- функция должна проверять результат ввода команды, если команда была принята оборудованием, тогда функция возвращает True, если выполнить команду не удалось -> возвращает False

Пример успешного выполнения
  
  ```text
  router# clear logging
  Clear logging buffer [confirm]
  router#
  ```

Пример неуспешного выполнения

  ```text
  router> clear logging
                 ^
  % Invalid input detected at '^' marker.
  router>
  ```

## Task4. Настройка оборудования

Написать функцию c сигнатурой `patch_interfaces(device: dict[str, str]) -> bool`, которая делает настройки на интерфейсах по следующему алгоритму (на примере cisco устройства):

- подключается к оборудованию
- собирает вывод команды `show ip interface brief`
- для каждого интерфейса с IP адресом формирует конфигурацию на основе jinja2 шаблона (шаблон ниже в примере)
- применяет полученную конфигурацию на устройстве (можно применять конфигурацию по мере разбора вывода `show ip interface brief`, т.е. для каждого интерфейса в отдельности, а можно собрать конфигурацию для всех интерфейсов в один большой патч и разово его применить - выбор логики остается за разработчиком)

Ключевые особенности, которым должна соответствовать функция:

- должны обрабатываться исключения из задания 2:
  - не подходят логин/пароль -> пишем в stdout "Неправильные логин/пароль для устройства" и возвращаем False из функции
  - таймаут подключения к устройству -> пишем в stdout "Таймаут подключения к устройству" и возвращаем False из функции
  - все неизвестные исключения -> пишем в stdout "Неизвестная ошибка при работе с устройством" и возвращаем False из функции
- кроме этого, нужно обеспечить проверку корректности вводимых конфигурационных команд средствами самой netmiko, и обработку исключения, возникающего в случае ошибки при конфигурации. В этом случае нужно писать в stdout "Ошибка при настройки устройства" и возвращать False из функции
- если конфигурация прошла успешно, то возвращать True из функции

Пример

```python
import re
from textwrap import dedent

from jinja2 import Template
from netmiko import ConnectHandler
from netmiko.exceptions import  # <ваша реализация>

template = Template(
    dedent(
        """
        interface {{ ifname }}
         no ip redirects
         no ip unreachables
         no ip proxy-arp
        exit
        """
    ).strip()
)

device = {
    "device_type": "cisco_xe",
    "host": "192.168.122.101",
    "username": "admin",
    "password": "P@ssw0rd",
}


def patch_interfaces(device: dict[str, str]) -> bool:
    # <ваша реализация>


if __name__ == "__main__":
    print(patch_interfaces(device))
```
