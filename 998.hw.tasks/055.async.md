# Async

## Task1. Использование API

Нужно написать скрипт, который асинхронно (не в потоках) опрашивает ресурс `https://dummyjson.com/quotes`, собирает возвращаемые цитаты, затем сохраняет их все в один yaml файл в формате вида

```yaml
author1:
    - quote1
    - quote2
author2:
    - quote1
    - quote2
    - quote3
```

Т.е. все цитаты группируются по авторам, затем данные сохраняются в виде списка словарей `dict[str, list[str]]`.

Требования к скрипту:

- количество одновременных запросов должно быть настраиваемым значением (например не более 10 одновременных запросов)
- параметры url должны вычисляться динамически, т.е. в скрипте нельзя прописать набор адресов заранее. Например делается первый запрос, в ответе на который есть общее число цитат и на основе размера ответа (пагинации) и общего числа цитат, уже собираются url для остальных данных
- количество цитат, возвращаемых за раз должно быть настраиваемым параметром, по-умолчанию это 30 объектов (так отдает ресурс), но скрипт должен корректно работать при различном числе объектов в одном ответе
- в каждый url добавляется параметр `delay=<value>`, где value случайное число от 300 до 3000 (для каждого запроса свое случайное число)

В итоге запрашиваемый url будет иметь вид `https://dummyjson.com/quotes?limit=20&skip=20&delay=1500`, где

- `limit=20` - количество объектов в одном ответе, является настраиваемым параметром (30 по умолчанию, если ничего не указывать)
- `skip=20` - сдвиг данных для 2, 3, 4... запросов для получения очередной страницы (пагинация данных). Для первого запроса значение будет 0
- `delay=1500` - эмулируемая задержка ответа, 1.5c в этом случае, случайное число от 300 до 3000 и для каждого запроса своё

Т.е. url выше это второй запрос данных, с задержкой в 1.5c со ограничением в 20 объектов на ответ.

## Task2. AsyncScrapli

Переписать скрипт из [Task1](/998.hw.tasks/053.threading.md#task1-массовый-сбор-вывода-команд) по массовому сбору команд таким образом. Все требования и вводные остаются теми же самыми. Про ограничение максимального числа одновременных подключений так же нужно не забыть, возможно применить `asyncio.Semaphore` для этого.
