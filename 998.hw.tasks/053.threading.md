# Threading

## Task1. Массовый сбор вывода команд

Написать скрипт, который собирает заданный список команд с устройств. Набор команд один и тот же для всех устройств, и представлен переменной `commands: list[str]` даже если это одна команда. Для подключения используется `scrapli` или `netmiko` (по желанию разработчика, но лучше `scrapli`, так как будет удобнее работать с отдельными командами + в дз по async нужно будет тот же самый функционал на `AsyncScrapli` сделать, меньше переписывать будет).

Данные об устройствах необходимо прочитать из yaml файла, в котором в виде списка словарей хранится информацию о параметрах каждого устройства. В yaml файле можно описывать как все параметры, необходимые библиотеке для подключения, так и только уникальные для устройства, а общие параметры внести в скрипт в качестве шаблона и перед подключением объединять общий шаблон с уникальными параметрами из yaml файла. Выбор способа остается за разработчиком. Файл располагается в том же каталоге, что и запускаемый скрипт.

Собранные выводы нужно сохранить в файл `<filename>` в каталоге `./outputs/<host>/`. Имя файла `<filename>` формируется из собранной команды, где все пробелы заменены на `_`, и если использовалась фильтрация, то она отброшена. Расширение `.txt` Например, для устройства `192.168.1.1`:

- команда `show version` -> файл `./outputs/192.168.1.1/show_version.txt`
- команда `show ip int br | e down` -> файл `./outputs/192.168.1.1/show_ip_int_br.txt`

Пример yaml файла с устройствами (только уникальные параметры, всё остальное определено через шаблон)

```yaml
- host: 192.168.122.101
- host: 192.168.122.120
  transport: telnet
- host: 192.168.122.121
```

Вопросы реализации скрипта, например сколько потоков использовать, как ставить задачи (через `map` или `submit`), как собирать результат (ждать полного завершения или использовать `as_completed`) остаются на усмотрение разработчика. Нужно реализовать такой вариант, что бы скрипт корректно собирал данные и сохранял их, при этом если в каком-либо потоке возникли ошибки (например устройство недоступно), то это не приводило бы к остановке всей программы. В этом случае устройство с ошибкой просто пропускается, без создания файла.

## Task2. Singleton

Модернизировать предыдущий скрипт, добавив в функционал watchdog, который следит за ошибками во всех потоках и пропускает сбор данных с устройства в случае, если количество ошибок превысило некоторый предел. Предел ошибок является настраиваемым параметром. Например, если есть опечатка в собираемой команде, тогда задача по сбору для каждого устройства завершается с ошибкой и по достижению установленного предела, сбор для очередных устройств будет пропущен. Для тестирования лучше установить небольшое число одновременных потоков.
